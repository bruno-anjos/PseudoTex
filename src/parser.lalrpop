use crate::my_parser::{Expr, Special};

grammar;

pub Main: Expr = {
    BEGIN <e:Any> END => e
};

pub Any: Expr = {
    <b: BasicExpr> => b,
    <b: BasicExpr> <e: Any> => Expr::MultipleExpr{ e1: Box::new(b), e2: Box::new(e) }
};

pub BasicExpr: Expr = {
    <e: Method> => e,
    <e: Assign> => e,
    <e: If> => e
};

pub Method: Expr = {
    SimpleMethod,
    ComplexMethod,
    SimpleEvent,
    ComplexEvent
};

pub SimpleMethod: Expr = {
    UPON <id: STRING> DO COLON <e: Any> END => Expr::Method{ name: id.to_string(), body: Box::new(e) }
};

pub ComplexMethod: Expr = {
    UPON <id: STRING> OPEN_PAR <args: Args> CLOSE_PAR DO COLON <e: Any> END =>
        Expr::MethodWithArgs{ name: id.to_string(), args: args, body: Box::new(e) }
};

pub SimpleEvent: Expr = {
    UPON EVENT <id: STRING> DO COLON <e: Any> END => Expr::Event{ name: id.to_string(), body: Box::new(e) }
};

pub ComplexEvent: Expr = {
    UPON EVENT <id: STRING> OPEN_PAR <args: Args> CLOSE_PAR DO COLON <e: Any> END =>
        Expr::EventWithArgs{ name: id.to_string(), args: args, body: Box::new(e) }
};

pub Args: Vec<String> = {
    <a: STRING> => vec![a.to_string()],
    <a: STRING> COMMA <mut args: Args> => { let mut res = vec![a.to_string()]; res.append(&mut args); res }
};

pub Assign: Expr = {
    <id:STRING> EQ <value:STRING> => Expr::Assign{ name: id.to_string(), value: value.to_string() }
};

pub If: Expr = {
    IF <condition: MultTerm> THEN <body: Any> END =>
        Expr::If{ condition: Box::new(condition), body: Box::new(body) },
    IF <condition: MultTerm> THEN <if_body: Any> ELSE <else_body: Any> END =>
        Expr::IfElse{ condition: Box::new(condition), if_body: Box::new(if_body), else_body: Box::new(else_body) },
};

pub Special: Special = {
    IN => Special::In,
    EXISTS => Special::Exists,
}

pub MultTerm: Expr = {
    <e: Term> => e,
    <e1: Term> <e2: MultTerm> => Expr::MultipleTerm { t1: Box::new(e1), t2: Box::new(e2) }
}

pub Term: Expr = {
    <s: STRING> => Expr::String(s.to_string()),
    <s: Special> => Expr::Special(s),
}

match {
    "="     => EQ,
    "upon"  => UPON,
    "event" => EVENT,
    "do"    => DO,
    ":"     => COLON,
    ","     => COMMA,
    "("     => OPEN_PAR,
    ")"     => CLOSE_PAR,
    "begin" => BEGIN,
    "end"   => END,
    "in"    => IN,
    "if"    => IF,
    "else"  => ELSE,
    "then"  => THEN,
    "exists"=> EXISTS,
    r"\w+"  => STRING
}
