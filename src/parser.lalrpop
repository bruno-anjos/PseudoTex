use crate::my_parser::{Expr, Special};

grammar;

pub Main: Expr = {
    <s: State> <b: MainBody> => Expr::MultipleExpr{ e1: Box::new(s), e2: Box::new(b) },
    <i: Interface> <b: MainBody> => Expr::MultipleExpr{ e1: Box::new(i), e2: Box::new(b) },
    <i: Interface> <s: State> <b: MainBody> =>
        Expr::MultipleExpr{
            e1: Box::new(
                Expr::MultipleExpr{
                    e1: Box::new(i),
                    e2: Box::new(s)
                }
            ),
            e2: Box::new(b)
        },
    <b: MainBody> => b,
};

pub Interface: Expr = {
    INTERFACE COLON <r: Requests> <i: Indications> => Expr::Interface{ reqs: Box::new(r), indics: Box::new(i) },
    INTERFACE COLON <r: Requests> => Expr::Interface{ reqs: Box::new(r), indics: Box::new(Expr::Empty) },
    INTERFACE COLON <i: Indications> => Expr::Interface{ reqs: Box::new(Expr::Empty), indics: Box::new(i) },
};

pub Requests: Expr = {
    REQUESTS COLON <r: MultiCall> => Expr::Requests{ requests: Box::new(r) }
};

pub Indications: Expr = {
    INDICATIONS COLON <i: MultiCall> => Expr::Indications{ indications: Box::new(i) }
};

pub MultiCall: Expr = {
    <m: MethodCall> => m,
    <m: MethodCall> <ms: MultiCall> => Expr::MultipleExpr{ e1: Box::new(m), e2: Box::new(ms) },
};

pub MethodCall: Expr = {
    <s: STRING> OPEN_PAR CLOSE_PAR => Expr::MethodCall{ name: s.to_string() },
    <s: STRING> OPEN_PAR <args: Args> CLOSE_PAR => Expr::MethodCallWithArgs{ name: s.to_string(), args: args },
	CALL <s: STRING> OPEN_PAR CLOSE_PAR => Expr::ProcedureCall{ name: s.to_string() },
	CALL <s: STRING> OPEN_PAR <args: Args> CLOSE_PAR => Expr::ProcedureCallWithArgs{ name: s.to_string(), args: args }
};

pub State: Expr = {
    STATE COLON <e: MultiLineMultiTerm> => Expr::State{ body: Box::new(e) }
};

pub MainBody: Expr = {
	<e: Init> => e,
	<e:TopLevel> => e,
	<e1: Init> <e2:TopLevel> => Expr::MultipleExpr{ e1: Box::new(e1), e2: Box::new(e2) }
};

pub Init: Expr = {
	UPON INIT DO COLON <body: MultiBody> => Expr::Init{ body: Box::new(body)},
	UPON INIT OPEN_PAR <args: Args> CLOSE_PAR DO COLON <e: MultiBody> =>
        Expr::InitWithArgs{ args: args, body: Box::new(e) }
};

pub Timer: Expr = {
	UPON TIMER <id: STRING> DO COLON <e: MultiBody> =>
		Expr::Timer{ name: id.to_string(), body: Box::new(e) },
	UPON TIMER <id: STRING> OPEN_PAR <args: Args> CLOSE_PAR DO COLON <e: MultiBody> =>
        Expr::TimerWithArgs{ name: id.to_string(), args: args, body: Box::new(e) }
};

pub CrashWithArgs: Expr = {
	UPON CRASH OPEN_PAR <args: Args> CLOSE_PAR DO COLON <body: MultiBody> =>
		Expr::CrashWithArgs{ args: args, body: Box::new(body)}
};

pub TopLevel: Expr = {
    <b: BasicExpr> => b,
    <b: BasicExpr> <e: TopLevel> => Expr::MultipleExpr{ e1: Box::new(b), e2: Box::new(e) }
};

pub Procedure: Expr = {
	PROCEDURE <id: STRING> COLON <body: MultiBody> => 
		Expr::Procedure{ name: id.to_string(), body: Box::new(body) },
	PROCEDURE <id: STRING> OPEN_PAR <args: Args> CLOSE_PAR COLON <body: MultiBody> => 
		Expr::ProcedureWithArgs{ name: id.to_string(), args: args, body: Box::new(body) },
};

pub SetupTimer: Expr = {
	SETUP TIMER <id: STRING> OPEN_PAR <args: Args> CLOSE_PAR =>
		Expr::SetupTimer{ name: id.to_string(), args: args },
	SETUP PERIODIC TIMER <id: STRING> OPEN_PAR <args: Args> CLOSE_PAR =>
		Expr::SetupPeriodicTimer{ name: id.to_string(), args: args }
};

pub CancelTimer: Expr = {
	CANCEL TIMER <id: STRING> =>
		Expr::CancelTimer{ name: id.to_string() },
	CANCEL PERIODIC TIMER <id: STRING> OPEN_PAR <args: Args> CLOSE_PAR =>
		Expr::CancelTimerWithArgs{ name: id.to_string(), args: args }
};

pub BasicExpr: Expr = {
	<e: Method> => e,
	<e: Timer> => e,
	<e: CrashWithArgs> => e,
	<e: Procedure> => e,
};

pub MultiBody: Expr = {
	<e: Body> => e,
	<e1: Body> <e2: MultiBody> => Expr::MultipleExpr{ e1: Box::new(e1), e2: Box::new(e2) }
};

pub ForEach: Expr = {
	FOREACH <condition: SingleLineMultiTerm> DO COLON <body: MultiBody> END =>
		Expr::ForEach{ condition: Box::new(condition), body: Box::new(body) }
};

pub Body: Expr = {
	<e: Assign> => e,
	<e: Conditional> => e,
	<e: Trigger> => e,
	<e: MethodCall> => e,
	<e: SetupTimer> => e,
	<e: CancelTimer> => e,
	<e: ForEach> => e,
};

pub Method: Expr = {
    SimpleMethod,
    ComplexMethod,
    SimpleEvent,
    ComplexEvent
};

pub Trigger: Expr = {
    TRIGGER <m: MethodCall> => Expr::Trigger{ method: Box::new(m) },
}

pub SimpleMethod: Expr = {
    UPON <id: STRING> DO COLON <e: MultiBody> => Expr::Method{ name: id.to_string(), body: Box::new(e) }
};

pub ComplexMethod: Expr = {
    UPON <id: STRING> OPEN_PAR <args: Args> CLOSE_PAR DO COLON <e: MultiBody> =>
        Expr::MethodWithArgs{ name: id.to_string(), args: args, body: Box::new(e) }
};

pub SimpleEvent: Expr = {
    UPON EVENT <id: STRING> DO COLON <e: MultiBody> => Expr::Event{ name: id.to_string(), body: Box::new(e) }
};

pub ComplexEvent: Expr = {
    UPON EVENT <id: STRING> OPEN_PAR <args: Args> CLOSE_PAR DO COLON <e: MultiBody> =>
        Expr::EventWithArgs{ name: id.to_string(), args: args, body: Box::new(e) }
};

pub Args: Vec<String> = {
    <a: STRING> => vec![a.to_string()],
    <a: STRING> COMMA <mut args: Args> => { let mut res = vec![a.to_string()]; res.append(&mut args); res }
};

pub Assign: Expr = {
    <id:STRING> EQ <value:STRING> => Expr::Assign{ name: id.to_string(), value: Box::new(Expr::String(value.to_string())) },
    <id:STRING> EQ <value:MethodCall> => Expr::Assign{ name: id.to_string(), value: Box::new(value) }
};

pub Conditional: Expr = {
	<e: If> END => e,
	<e: IfComposed> <next_conditional: NextConditional> END =>
		Expr::MultipleExprNoNewLine{e1: Box::new(e), e2: Box::new(next_conditional)},
};

pub If: Expr = {
	IF <condition: SingleLineMultiTerm> THEN <body: MultiBody> =>
		Expr::If{ condition: Box::new(condition), body: Box::new(body) },
};

pub IfComposed: Expr = {
	IF <condition: SingleLineMultiTerm> THEN <body: MultiBody> =>
		Expr::IfComposed{ condition: Box::new(condition), if_body: Box::new(body) },
};

pub NextConditional: Expr = {
	<e: SimpleNextConditional> => e,
	<e: ComposedNextConditionals> => e,
};

pub SimpleNextConditional: Expr = {
	<e: ElseIf> => e,
	<e: Else> => e
};

pub ComposedNextConditionals: Expr = {
	<elseIf: ElseIfComposed> <next_conditional: NextConditional> => Expr::MultipleExprNoNewLine{e1: Box::new(elseIf), e2: Box::new(next_conditional)}
};

pub ElseIf: Expr = {
	ELIF <condition: SingleLineMultiTerm> THEN <else_if_body: MultiBody> =>
		Expr::ElseIf{ condition: Box::new(condition), else_if_body: Box::new(else_if_body) }
};

pub ElseIfComposed: Expr = {
	ELIF <condition: SingleLineMultiTerm> THEN <else_if_body: MultiBody> =>
		Expr::ElseIfComposed{ condition: Box::new(condition), else_if_body: Box::new(else_if_body) }
};

pub Else: Expr = {
	ELSE <else_body: MultiBody> => Expr::Else{else_body: Box::new(else_body)}
};

pub Special: Special = {
    IN => Special::In,
    EXISTS => Special::Exists,
    NOT_EXISTS => Special::NotExists,
    NOT_IN => Special::NotIn,
    SET_MINUS => Special::SetMinus,
    UNION => Special::Union,
    INTERSECT => Special::Intersect,
    UNDEFINED => Special::Undefined,
};

pub MultiLineMultiTerm: Expr = {
    <e: Term> => e,
    <e1: Term> <e2: MultiLineMultiTerm> => Expr::MultiLineMultipleTerm { t1: Box::new(e1), t2: Box::new(e2) }
};

pub SingleLineMultiTerm: Expr = {
    <e: Term> => e,
    <e1: Term> <e2: SingleLineMultiTerm> => Expr::SingleLineMultipleTerm { t1: Box::new(e1), t2: Box::new(e2) }
};

pub Term: Expr = {
    <s: STRING> => Expr::String(s.to_string()),
    <s: Special> => Expr::Special(s),
};

match {
    "="     => EQ,
    "upon"  => UPON,
    "event" => EVENT,
    "do"    => DO,
    ":"     => COLON,
    ","     => COMMA,
    "("     => OPEN_PAR,
    ")"     => CLOSE_PAR,
    "state" => STATE,
    "interface" => INTERFACE,
    "requests"    => REQUESTS,
    "indications" => INDICATIONS,
    "trigger" => TRIGGER,
    "begin" => BEGIN,
    "end"   => END,
    "if"    => IF,
    "else"  => ELSE,
    "elif"  => ELIF,
    "then"  => THEN,
    "in"    => IN,
	"exists"=> EXISTS,
	"init" => INIT,
	"timer" => TIMER,
	"crash" => CRASH,
	"procedure" => PROCEDURE,
	"call" => CALL,
	"setup" => SETUP,
	"periodic" => PERIODIC,
	"cancel" => CANCEL,
	"for each" => FOREACH,
    "\\"     => SET_MINUS,
    "!in"   => NOT_IN,
    "!exists"   => NOT_EXISTS,
	"unite" => UNION,
    "intersect" => INTERSECT,
    "undefined" => UNDEFINED,
    r"\w+"  => STRING
}
